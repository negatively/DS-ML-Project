# -*- coding: utf-8 -*-
"""Wine Quality Prediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WN3XVPMIfRQwm6aIPvLLoOWkp6hsFPP4

# WINE QUALITY PREDICTION

## Domain Proyek

Domain proyek yang penulis pilih untuk proyek machine learning kali ini adalah food and beverage dengan judul proyek "Prediksi Kualitas Red Wine menggunakan Random Forest"

## 1. Memanggil *Library* Yang Dibutuhkan
"""

# Library Pengolahan Data
import pandas as pd
import numpy as np
from collections import Counter
from zipfile import ZipFile
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler

# Library Visualisasi Data
import matplotlib.pyplot as plt
import seaborn as sns

# Library untuk Pemodelan
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import GridSearchCV
from sklearn.metrics import accuracy_score, classification_report

"""## 2. Mempersiapkan *Dataset*

Data yang digunakan untuk proyek kali ini adalah Red Wine Dataset yang diunduh dari [dataset Kaggle](https://www.kaggle.com/uciml/red-wine-quality-cortez-et-al-2009). Dataset tersebut memiliki jumlah data sebanyak 1599 baris dengan 11 fitur dan 1 target. Fitur yang dimaksud adalah _fixed acidity_, _volatile acidity_, _citric acid_, _residual sugar_, _chlorides_, _free sulfur dioxide_, _total sulfur dioxide_, _density_, _pH_, _sulphates_, dan _alcohol_ yang bertipe data numerik. Sedangkan _quality_ adalah target yang juga bertipe data numerik.

### 2.1 Mengunduh Dataset Dari Kaggle
"""

# Melakukan Pengaturan API Kaggle 
! pip install -q kaggle
from google.colab import files
files.upload()
! mkdir ~/.kaggle
! cp kaggle.json ~/.kaggle/
! chmod 600 ~/.kaggle/kaggle.json

# Mengambil Dataset Dari Kaggle
!kaggle datasets download -d uciml/red-wine-quality-cortez-et-al-2009

"""### 2.2 Memuat Dataset"""

# Ekstrasi Dataset
path = '/content/red-wine-quality-cortez-et-al-2009.zip'
with ZipFile(path, 'r') as zip_ref:
    zip_ref.extractall('working')

# Memuat Dataset Dengan Library Pandas
wines = pd.read_csv('/content/working/winequality-red.csv')

"""## 3. Pemahaman Data"""

# Melihat Isi Dataset
wines

"""Berikut adalah penjelasan dari variabel-variabel pada dataset Wine :
* **fixed acidity** : kandungan asam yang bersifat fixed
* **volatile acidity** : kandungan asam yang bersifat volatile
* **citric acid** : kandungan asam sitrat
* **residual sugar** : jumlah kandungan gula residual setelah hasil fermentasi 
* **chlorides** : kandungan garam pada wines
* **free sulfur dioxide** : kandungan SO2 dalam bentuk kesetimbangan antara molekul SO2 (sebagai gas terlarut) dan ion bisulfit
* **total sulfur dioxide** : jumlah keseluruhan S02
* **density** : tingkat density cairan
* **pH** : menggambarkan seberapa asam atau basa anggur dalam skala dari 0 (sangat asam) hingga 14 (sangat basa)
* **sulphates** : kadar aditif wines yang dapat berkontribusi pada tingkat gas sulfur dioksida (S02)
* **alcohol** : persentase kandungan alkohol pada wines
* **quality** : variabel output berdasarkan data sensorik dengan skor dari 0 sampai 10

## 4. Eksplorasi Data

Kemudian dilakukan juga eksplorasi data dan visualisasi tentang korelasi antar kolomnya.

### 4.1 EDA - Deskripsi Variabel
"""

# Melihat Informasi Dataset
wines.info()

# Melihat deskripksi tiap kolom
wines.describe()

"""### 4.2 EDA - Missing values dan Outliers"""

# Melakukan cek data kosong
wines.isna().sum()

# Mengidentifikasi ouliers
cols = [col for col in wines.columns]
for col in cols:
  sns.catplot(x=col, kind='box', data=wines, aspect=3, height=3, palette = 'Set3')
  plt.title(f'Boxplot {col}')

"""Mengapus data yang memiliki outlier di lebih dari 2 fitur. Outliers sendiri dapat mempengaruhi performa dari mode"""

# Membuat Fungsi Untuk Mendeteksi Baris yang memiliki lebih dari 2 outliers pada kolomnya
def detect_outliers(df, features):
  outlier_indices = []

  for f in features:
    # Quartile Pertama
    Q1 = df[f].quantile(0.25)
    # Quartile Kedua
    Q3 = df[f].quantile(0.75)
    # Interquartile Range
    IQR = Q3 - Q1
    # Deteksi outlier beserta index barisnya 
    outlier_list_col = df[((df[f] < Q1 - 1.5 * IQR)|(df[f] > Q3 + 1.5 * IQR))].index
    # Menambahkannya kedalam list
    outlier_indices.extend(outlier_list_col)

  # Menghitung jumlah outlier untuk tiap index
  outlier_indices=Counter(outlier_indices)    
  # Memilih index yang memiliki outlier lebih dari 2
  multiple_outliers = list(i for i, v in outlier_indices.items() if v > 2)
    
  return multiple_outliers

# Melihat Jumlah baris yang memiliki outlier lebih dari 2
print(f"Total baris yang memiliki outliers bernilai > 2 : {len(detect_outliers(wines,cols))} ")
# Cek lokasi
wines.loc[detect_outliers(wines,cols)]

# Melakukan drop outlier
wines = wines.drop(detect_outliers(wines,cols),axis = 0).reset_index(drop = True)
wines.shape

"""### 4.3 EDA - Univariate Analysis

Analisis univariat merupakan analisis yang digunakan pada satu variabel dengan tujuan untuk mengetahui dan mengidentifikasi karakteristik dari variabel tersebut.
"""

# Melihat Distribusi Quality
plt.figure(figsize=(12, 6))
sns.countplot(x="quality", data=wines, palette='husl');
plt.title('Persebaran Data Quality')

"""Berdasarkan grafik persebaran data quality, kita dapatkan bahwa persebarannya paling banyak pada quality 5 dan 6. Nantinya nilai quality akan dikelompokkan menjadi 2 kelas, yaitu good (1) untuk quality > 6.5 and not good (0) untuk quality < 6.5.

### 4.4 EDA - Multivariate Analysis

Multivariat analisis adalah seperangkat model statistik yang meneliti pola dalam data multidimensi dengan mempertimbangkan, sekaligus, beberapa variabel data.
"""

corr = wines.corr()
plt.figure(figsize=(15,10))
sns.heatmap(corr, xticklabels=corr.columns, yticklabels=corr.columns, annot=True, cmap=sns.diverging_palette(220, 20, as_cmap=True))
plt.title("Correlation Matrix semua fitur")
plt.savefig('correlation.png')
plt.show()

"""Berdasarkan correaltion matrik diatas, fitur yang memiliki korelasi diantara -0.1 sampai 0.1 dengan fitur quality adalah **residual sugar, free sulfur dioxide,** dan **pH**. Oleh karena itu fitu tersebut nantinya dapat di drop

## 5. Pengolahan Data

Tahap dimana data akan diolah sehingga sudah siap untuk proses pemodelan.

### 5.1 Mempersiapkan Data Untuk Klasifikasi

Mengelompokkan data quality menjadi good dan not good, dimana data yang memiliki label good merupakan red wine yang baik untuk kesehatan. Data yang memiliki nilai quality 0 sampai 6 merupakan wine dengan kualitas not good. Sedangkan data yang memiliki nilai 7 sampai 10 merupakan wine dengan kualitas good.
"""

# Membuat fitur klasifikasi good dan not good pada fitur quality
wines['good_quality'] = [1 if n > 6.5 else 0 for n in wines['quality']]
# Melihat proporsi klasifikasi
plt.figure(figsize=(12, 6))
sns.countplot(x="good_quality", data=wines, palette='husl');
plt.title('Proporsi Good Quality')

"""Tidak mengikutkan fitur residual sugar, free sulfur dioxide, dan pH karena memiliki tingkat korelasi berada diantara -0.1 sampai 0.1 terhadap quality"""

# Memisahkan fitur dan target
X = wines.drop(['quality', 'good_quality', 'residual sugar', 'free sulfur dioxide', 'pH'], axis = 1)
y = wines['good_quality']

"""Membagi dataset menjadi data train dan data test dengan rasio 80% untuk data train dan 20% untuk data test. Tujuan dilakukan pembagian adalah supaya dapat menguji performa model. Dimana data train digunakan untuk melatih model, sedangkan data _test_ merupakan data yang digunakan untuk menguji model setelah melalui pelatihan data."""

# Membagi train dan test dataset
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 610)

"""### 5.2 Standarisasi

Standarisasi yang dilakukan adalah menggunakan teknik StandardScaler, dimana data akan dikurangi dengan nilai rata-rata kemudian dibagi dengan standar deviasi, sehingga dataset akan memiliki standar deviasi sebesar 1 dan rata-rata sama dengan 0.
"""

# Standarisasi Fitur
scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

"""## 6. Pemodelan

Pada langkah ini dibuat sebuah model Random Forest dengan library scikit-learn RandomForestClassifier. Dalam pemodelan ini model dibuat tanpa parameter tambahan.
"""

# Pelatihan model baseline
rf = RandomForestClassifier()
rf.fit(X_train, y_train)

# Pengujian model baseline
y_pred = rf.predict(X_test)
bs_report = classification_report(y_test,y_pred,output_dict=True, target_names=['Not Good','Good'])
pd.DataFrame(bs_report).transpose()

"""## 7. Tuning Model

Di langkah ini model baseline yang sudah dibuat kemudian dikembangkan kinerjanya. Untuk meningkatkan kinerja model maka dilakukan pencarian hyperparameter yang optimal untuk model dengan GridSearchCV. Setelah ditemukan hyperparameter terbaik dari proses GridSearchCV, kemudian diterapkan ke model baseline
"""

# Hyper parameter yang akan dituning
params_rf = {'n_estimators':[5,10,15,20,25,30,40,50],
            'max_depth':[1,3,5,7,9,11,13,15,17],
            'max_features':['log2','sqrt']}

# Pencarian parameter terabaik dengan Grid Search CV
rf = RandomForestClassifier()
grid_rf = GridSearchCV(estimator = rf,
                      param_grid = params_rf,
                      cv=3,
                      scoring = 'accuracy',
                      verbose = 1,
                      n_jobs = -1)
grid_rf.fit(X_train, y_train)
y_pred = grid_rf.predict(X_test)

# Hasil tuning hyperparameter dengan skor terbaik yang didapatkan
print(f"Best Parameter : {grid_rf.best_params_}")
print(f"Best Score : {grid_rf.best_score_}")

# Menerapkan hyperparameter hasil tuning
rf = RandomForestClassifier(max_depth = 13, n_estimators = 10, max_features='sqrt')
rf.fit(X_train, y_train)
# Pengujian Model Terhadap Test Dataset
y_pred = rf.predict(X_test)
# Hasil klasifikasi tuning model
tm_report = classification_report(y_pred,y_test,output_dict=True, target_names=['Not Good','Good'])
pd.DataFrame(tm_report).transpose()

"""## 8. Evaluasi

Model yang telah dibuat kemudian dilakukan evaluasi. Karena model merupakan tipe klasifikasi, maka evaluasinya akan digunakan metriks akurasi, f1-score, precision, dan recall.
"""

# Membuat dataframe untuk menampung hasil evaluasi
header = pd.MultiIndex.from_product([['Not Good','Good'],
                                     ['accuracy','precision','f1-score','recall']])
metrics = pd.DataFrame(columns =header, index=['Model Baseline', 'Model Tuning'])

metrics

"""Hasil evaluasi pada model baseline dan model tuning adalah sebagai berikut,"""

# Membandingkan hasil model baseline dengan model tuning
metrics.loc['Model Baseline',('Not Good', 'precision')]= bs_report['Not Good']['precision']
metrics.loc['Model Baseline',('Not Good','recall')] = bs_report['Not Good']['recall']
metrics.loc['Model Baseline',('Not Good','f1-score')] = bs_report['Not Good']['f1-score']
metrics.loc['Model Baseline',('Not Good','accuracy')] = bs_report['accuracy']

metrics.loc['Model Baseline',('Good', 'precision')]= bs_report['Good']['precision']
metrics.loc['Model Baseline',('Good','recall')] = bs_report['Good']['recall']
metrics.loc['Model Baseline',('Good','f1-score')] = bs_report['Good']['f1-score']
metrics.loc['Model Baseline',('Good','accuracy')] = bs_report['accuracy']

metrics.loc['Model Tuning',('Not Good', 'precision')]= tm_report['Not Good']['precision']
metrics.loc['Model Tuning',('Not Good','recall')] = tm_report['Not Good']['recall']
metrics.loc['Model Tuning',('Not Good','f1-score')] = tm_report['Not Good']['f1-score']
metrics.loc['Model Tuning',('Not Good','accuracy')] = tm_report['accuracy']

metrics.loc['Model Tuning',('Good', 'precision')]= tm_report['Good']['precision']
metrics.loc['Model Tuning',('Good','recall')] = tm_report['Good']['recall']
metrics.loc['Model Tuning',('Good','f1-score')] = tm_report['Good']['f1-score']
metrics.loc['Model Tuning',('Good','accuracy')] = tm_report['accuracy']

# Menampilkan Hasil pembandingan metrics
metrics

"""Kemudian untuk mencari fitur yang paling berpengaruh, mari kita visualisasikan feature importances dari model,"""

# Melihat fitur yang paling berpengaruh
feat_importances = pd.Series(rf.feature_importances_, index=X.columns)
feat_importances.nlargest(25).plot(kind='barh',figsize=(10,10))
plt.title("Feature Importance")
plt.show()

"""Dari visualisasi tersebut dapat dilihat bahwa 3 fitur paling berpengaruh pada prediksi kualitasi wine adalah tingkat alcohol, sulphates, dan total sulfur dioxide."""

# Filtering wines hanya untuk good quality
wines_temp = wines[wines['good_quality']==1]
display(wines_temp.describe())
# Filtering wines hanya untuk not good quality
wines_temp2 = wines[wines['good_quality']==0]
display(wines_temp2.describe())

"""## Kesimpulan

Dengan melihat detail dari good quality dan not good quality, kita dapat melihat bahwa wines dengan kualitas baik memiliki kadar alkohol rata-rata lebih tinggi, rata-rata memiliki keasaman volatil yang lebih rendah, kadar sulfat rata-rata yang lebih tinggi, dan kadar gula residual rata-rata yang lebih tinggi.

### Referensi
* P. Cortez, A. Cerdeira, F. Almeida, T. Matos and J. Reis. Modeling wine preferences by data mining from physicochemical properties.
In Decision Support Systems, Elsevier, 47(4):547-553, 2009.
* https://www.kaggle.com/namanmanchanda/red-wine-eda-and-classification
* https://www.kaggle.com/tommorowsengineer/wine-quality-classification-100-accuracy-with-knn
"""

